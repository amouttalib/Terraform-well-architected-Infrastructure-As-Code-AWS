locals {
  state_file_folders = "here is the folder path for state files"
}
locals {
  mime_types = jsondecode(file("${path.module}/${local.state_file_folders}/mime.json"))
  #if we don't define the content type for the state files,
  #AWS will automatically assign for us
  #the files can't be treated as state files for website
  #it's probably that .ipg files won't be displayed in webpage
}

# since cloudfront is used in front of S3
# s3 doesn't need to be public and its internet and website settings can be omitted
#============================================================
#1 to create s3 bucket to store state files
    #1.1 to create s3 bucket for the web (with CORS settings if any)
    #1.2 to create s3 bucket policy
    # the policy can be generated by Cloudfront AWS
    # or created manually using data source in terraform
    #1.3 to attach the policy to s3
#2 to upload state files from locally to s3 (index.html, ....)
#(step 3 & 4 as below can be omitted if there is only one bucket at this stage)
# if the project requires the main bucket to get info
# from other buckets, CORS settings are needed as well.
#3 to create s3 root bucket to translate the requests to one
    #3.1 to create s3 bucket 
    #3.2 to create s3 bucket policy
    #3.3 to attach the policy to s3 
#4 to upload another index.html to the root/main bucket if any
#5 to configure s3 to trigger SQS
  # later sqs will trigger lambda,
  # once a new file uploads to s3, lambda will invalidate the file in cache

#============================================================
#1 below is to create s3 for storing files like index.html
resource "aws_s3_bucket" "example" {
  bucket = "${local.bucket_name_for_web}"
  force_destroy = true
  tags = {
    Name        = "${local.bucket_name_for_web}"
    Environment = "Dev"
  }
}
# as the project won't apply root bucket, some of the below resources are 
# commented out for reference only.
# below is to add CORS
/*
resource "aws_s3_bucket_cors_configuration" "example" {
  bucket = aws_s3_bucket.example.id
  cors_rule {
    allowed_headers = ["*"]
    allowed_methods = ["PUT", "POST"]
    allowed_origins = ["https://www.${local.domain_name}"]
    expose_headers  = ["ETag"]
    max_age_seconds = 3000
  }

  cors_rule {
    allowed_methods = ["GET"]
    allowed_origins = ["*"]
  }
}  

# below is to host web on s3
# Cloudfront is applied in this project, s3 won't need this setup.
resource "aws_s3_bucket_website_configuration" "example" {
  bucket = aws_s3_bucket.example.id

  index_document {
    suffix = "index.html"
  }
}
*/
# below is to enable versioning
resource "aws_s3_bucket_versioning" "example"{
    bucket = aws_s3_bucket.example.id
    versioning_configuration {
      status = "Enabled"
    }
}
# below is to create s3 bucket policy
# after we create the cloudfront, AWS will automatically create a policy for s3.
# here, we use terraform to create the same policy
data "aws_iam_policy_document" "example" {
  statement {
		actions = ["s3:GetObject"]

		resources = ["${aws_s3_bucket.example.arn}/*"]

		principals {
			type        = "Service"
			identifiers = ["cloudfront.amazonaws.com"]
		}
		condition {
			test     = "StringEquals"
			variable = "AWS:SourceArn"
			values   = [aws_cloudfront_distribution.example.arn]
		}
	}
  depends_on = [ 
    aws_cloudfront_distribution.example
   ]
}
#below is to attach the policy to s3
resource "aws_s3_bucket_policy" "example" {
  bucket = aws_s3_bucket.example.id
  policy = data.aws_iam_policy_document.example.json
  depends_on = [ 
    data.aws_iam_policy_document.example
  ]
}

#2 below is to upload website state files to the newly built s3 bucket
resource "aws_s3_object" "upload_state_files" {
  for_each = fileset("./${local.state_file_folders}/", "**/*")
  bucket = aws_s3_bucket.example.id
  key = each.value
  source = "./${local.state_file_folders}/${each.value}"
  etag = filemd5("./${local.state_file_folders}/${each.value}")
  content_type = lookup(local.content_types, regex("\\.[^.]+$",lower(each.value)), null)
  # content type needs to be specified in s3 bucket
  # otherwise all uploaded file will be treated as attachment
  # click on the file will not serve, but makes you download the file...
  # we wish the files to serve as website files. a json file of content_types is one of the solutions.
  # the terraform will lookup the state file's extension in the file, and make sure 
  # after uploading, the content_type of "index.html" will be "text/html", not attachment.
  
  # Note: convert all update files' extensions to be lower case!!!
  # those in upper case won't be properly retrieved in the json document
  depends_on = [ 
    aws_s3_bucket_policy.example
   ]
}
# below is to check for testing purpose:
output "content_type" {
  value=[for key in aws_s3_object.upload_state_files: key.content_type]
}

#5 S3 to trigger SQS
resource "aws_s3_bucket_notification" "example" {
  bucket = aws_s3_bucket.example.id
  queue {
    id        = aws_sqs_queue.example.id
    queue_arn = aws_sqs_queue.example.arn
    events    = ["s3:ObjectCreated:*"]
  }
  depends_on = [
    aws_sqs_queue.example
  ]
}