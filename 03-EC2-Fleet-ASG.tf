locals {
  ami_for_web="ami's id"
  # this image is created from an existing EC2
  # where user data is added and port 80 is opened
  # in practice, we can create EC2 with necessary updates and installations 
  # make an image from it and use this image in the EC2 Fleet later
  key_pair_name="${local.prefix}-keypair-EC2"
  private_key_file="./${local.key_pair_name}.pem"
  }
#==================================================
#1 to create a Key Pair
  #1.1 to create SSH Key Pair
  #1.2 or to create AWS Key Pair using Public Key
  #1.3 to Download the Private Key to your laptop
  #1.4 to validate the Key Pair

#2 before ASG, we need to build:
  #2.1 Target Group
  #2.2 Security Group for ALB
  #2.3 ALB
  #2.4 allow traffic between Security Groups of ALB and ASG
    # the above will be created in the ALB.tf file

#3 to create ASG launch template
  # AMI + instance type
  # EC2 user data
  # EBS
  # SG
  # SSH Key Pair
  # IAM Roles for EC2
  # Network + Subnets
  # LB 

#4 to create ASG finally

#5 (question) EC2 instances must have a public IP assigned or they fail target group health checks?
  # one solution is to use NAT; 
  # the other one is to launch EC2 based on patched AMI
#6 Refresh EC2s by updating AMI --> updating template -(instance refresh)-> recreate all EC2s
#==================================================

#1 below is to create the Key Pair for EC2
  # this key pair can be used to SSH login EC2 as developer
    #1.1 to create SSH Key Pair
      #1.1.1 to create the pair using terraform
        #(AWS doesnot recommend to use it in the production environment. unless the terraform statefile is encrypted)
resource "tls_private_key" "dev_key"{
    algorithm = "RSA"
    rsa_bits = 4096
}
        #algorithm can be RSA, ECDSA or ED25519
        #Note: 
        #You access your public key 
        #by tls_private_key.dev_key.public_key_openssh 
        #So this is what you provide in the public_key field 
        #while creating a key pair using terraform.

      #1.1.2 to create the SSH pair using terminal
        # $ ssh-keygen -t rsa -b 4096
        #the public key is saved in SSHKeyPair.pub

    #1.2 to Create AWS Key Pair 
#resource "aws_key_pair" "generated_key" {
  #key_name   = local.key_pair_name
  #public_key = tls_private_key.dev_key.public_key_openssh
  
#}
      #or, if we use terminal to generate key pair locally
#resource "aws_key_pair" "generated_key2" {
  #key_name   = var.key_pair_name
  #public_key = file("SSHKeyPair.pub")
#}

    #1.3 to download private key
      #1.3.1 if we use terminal to generate the SSH key pair
      #the private key already saved with the public key in the local file
      #1.3.2 if we use terraform, the private key file is save within project folder

resource "aws_key_pair" "generated_key" {
  key_name   = local.key_pair_name
  public_key = tls_private_key.dev_key.public_key_openssh

}
resource "local_sensitive_file" "private_key" {
  filename = local.private_key_file
  content = tls_private_key.dev_key.private_key_pem

}
# the key pair generated by terraform is used for one-time purpose
# whenever terraform detroy is executed, the private key file should be deleted
# otherwise, next time a new pair can't be created after terraform-apply.
resource "null_resource" "delete_files" {
  triggers = {
      local_file=local.private_key_file
    }

  provisioner "local-exec" {
    when = destroy
    command = "rm -f ${self.triggers.local_file}"
    on_failure = continue
  }
}

    #1.4 to validate the key pair after the EC2 is created
      # go to EC2 --> Network and Security --> Key Pair

#============================================================
# Notes:
# The EC2 itself may not open Port 80 initially
# need user data to install httpd, 
# can also install nmap($nmap localhost) to see which ports are open 
# if port 80 on EC2 is not open:
# user can't connect the website using public ip
# neither can ALB get a response to the health check
#====================================================
# using below command in the terminal to ssh connect to public EC2
# $ chmod 400 the/name/of/the/private/key/file (this is extremely important to restrict access to the private key file)
# $ ssh -i the/path/of/private/key/file ec2-user@public_ip_from_EC2
#===============================================
#3 below is to create a launch template for t2.micro
# the instance types that are allowed in this project have been defined in the '01-variables.tf'
resource "aws_launch_template" "primary" {
  name = "${local.prefix}-template-primary"
  description="Public EC2 template for web"
  image_id = local.ami_for_web
  instance_type = local.instance_type
  key_name = aws_key_pair.generated_key.key_name
  
  network_interfaces {
    security_groups = [local.ec2_security_group_id,local.ec2_security_group_id_ssh]
    delete_on_termination = true
  }

  # there is user_data already in this AMI, no need to set user data here
  # if ALB is put in front of EC2, EC2 doesn't need to be assigned a public ip
  # however EC2 needs to update and install httpd before it can pass the health check from ALB
  # i prefer not to expose EC2 to public internet unless necessary and 
  # i can use AWS EC2 Instance Connect to securely access to EC2 with private ip addresses
   
  lifecycle {
    create_before_destroy = true
  }
}
#==================================================
#4 to create ASG finally
resource "aws_autoscaling_group" "the name of the resource" {
  name = "${local.prefix}-asg"
  force_delete = true
   mixed_instances_policy {
    launch_template {
      launch_template_specification {
        launch_template_id = aws_launch_template.primary.id
      }
      override {
        instance_type = local.instance_type
        weighted_capacity = 1
      }        
      override {
        instance_type = local.instance_type_alternative
        weighted_capacity = 1
      }
      # the above is to define allowed instances for ASG
      # the primary instance is t2.micro
      # however, not all AZs support t2
      # we need to allow ASG create more than one instance type
    } 
  }
  vpc_zone_identifier = local.all_subnets

  target_group_arns = [local.target_group_arn]
  #if there's any change to ALB or NLB, asg should ignore the changes
  lifecycle {
    ignore_changes = [
      load_balancers, target_group_arns
    ]
  }

  desired_capacity   = 2
  max_size           = 3
  min_size           = 1

  health_check_type = "ELB"
  health_check_grace_period = 300

  instance_refresh {
    strategy = "Rolling"
    preferences {
      min_healthy_percentage = 50
    }
    triggers = ["tag"]
  }
  # there are 3 situations which automatically trigger instance refresh in ASG
  # values in the [triggers] are additional elements set to trigger a refresh
}

resource "aws_autoscaling_policy" "primary" {
  name                   = "${local.prefix}-asgpolicy-dynamic"
  policy_type            ="TargetTrackingScaling"
  target_tracking_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ASGAverageCPUUtilization"
    }

    target_value = 40.0
  }
  # if the usage of CPU over 40, it's time to scale out
  autoscaling_group_name = aws_autoscaling_group.primary.name
}

